/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Name.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Name
 #	author : miyako
 #	2025/07/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Name.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Name
            
			case 1 :
				Get_localized_name(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
static void _getKey(PA_ObjectRef returnValue, NSURL *url, const char *property, NSURLResourceKey key) {
    
    @autoreleasepool {
        if(url) {
            NSString *localizedName = nil;
            [url getResourceValue:&localizedName forKey:key error:nil];
            if(localizedName) {
                ob_set_s(returnValue, property, [localizedName UTF8String]);
            }
        }
    }
}
#endif

void Get_localized_name(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    std::string platformPath;
    PA_ObjectRef item = PA_GetObjectParameter(params, 1);
    if(item){
        
        object_class_t itemClass = _ob_class(item);
        switch (itemClass) {
            case object_class_file:
                file_object_to_path(item, platformPath);
                break;
            case object_class_folder:
                folder_object_to_path(item, platformPath);
                break;
            default:
                break;
        }
        if(platformPath != ""){
            
#if VERSIONWIN
            CUTF16String wstr;
            C_TEXT pp;
            pp.setUTF8String((const uint8_t *)platformPath.c_str(), platformPath.length());
            pp.copyUTF16String(&wstr);
            
#define BUFFERLENGTH 1024
    LPCTSTR lpFile = (LPCTSTR)wstr.c_str();
    DWORD bufferLength = BUFFERLENGTH;
    wchar_t lpResult[BUFFERLENGTH];
            
            HRESULT res =AssocQueryString(
                                          ASSOCF_NONE,
                                          ASSOCSTR_FRIENDLYDOCNAME,
                                          lpFile,
                                          NULL,
                                          lpResult,
                                          &bufferLength
                                          );
            if ((res == S_OK) && ( bufferLength != 0)){
                ob_set_a(returnValue, L"localizedDescription", (const wchar_t *)lpResult);
            }
            
            
            
            SHFILEINFO shfi;
            SHGetFileInfo(
                          lpFile,
                          FILE_ATTRIBUTE_NORMAL,
                          &shfi,
                          sizeof(SHFILEINFO),
                          SHGFI_DISPLAYNAME | SHGFI_TYPENAME
                          );
            
            if (wcslen(shfi.szDisplayName) != 0) {
                ob_set_a(returnValue, L"localizedName", (const wchar_t*)shfi.szDisplayName);
            }
            //ob_set_a(returnValue, L"localizedLabel", (const wchar_t *)shfi.szTypeName);

#endif
            
#if VERSIONMAC
//            ob_set_s(returnValue, "platformPath", platformPath.c_str());
            NSString *str = [NSString stringWithUTF8String:platformPath.c_str()];
            NSURL *url = [NSURL fileURLWithPath:str];
            _getKey(returnValue, url, "localizedName", NSURLLocalizedNameKey);
            _getKey(returnValue, url, "localizedLabel", NSURLLocalizedLabelKey);
            _getKey(returnValue, url, "localizedTypeDescription", NSURLLocalizedTypeDescriptionKey);
//            _getKey(returnValue, url, "localizedFormatDescription", NSURLVolumeLocalizedFormatDescriptionKey);
            NSString *pathExtension = [str pathExtension];
            if(pathExtension) {
                CFStringRef uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension,
                                                                        (__bridge CFStringRef)pathExtension,
                                                                        NULL);
                if (uti) {
                    CFStringRef desc = UTTypeCopyDescription(uti);
                    if (desc) {
                        ob_set_s(returnValue, "localizedDescription", [(__bridge NSString *)desc UTF8String]);
                        CFRelease(desc);
                    }
                    CFRelease(uti);
                }
            }
#endif
        }
    }
    

    PA_ReturnObject(params, returnValue);
}

#pragma mark -

static object_class_t _ob_class(PA_ObjectRef f){
    
    PA_Variable    cbparams[1];
    cbparams[0] = PA_CreateVariable(eVK_Object);
    PA_SetObjectVariable(&cbparams[0], f);
    PA_Variable classObject = PA_ExecuteCommandByID(1730 /*OB Class*/, cbparams, 1);
    if(PA_GetVariableKind(classObject) == eVK_Object){
        PA_ObjectRef i = PA_GetObjectVariable(classObject);
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"name", 4);
        PA_Unistring NAME = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        if(PA_GetObjectPropertyType(i, &NAME) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(i, &NAME);
            PA_Unistring name = PA_GetStringVariable(p);
            
            C_TEXT c;
            c.setUTF16String(&name);
            CUTF8String _name;
            c.copyUTF8String(&_name);
            if(_name == (const uint8_t *)"File") {
                return object_class_file;
            }
            if(_name == (const uint8_t *)"Folder") {
                return object_class_folder;
            }
        }
    }
    
    return object_class_none;
}

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1567 /*4D.Folder*/);
}

static void set_object_property(PA_ObjectRef o, const char *key, PA_Variable value) {
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)key, (uint32_t)strlen(key));
    PA_Unistring _key = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    PA_SetObjectProperty(o, &_key, value);
    PA_DisposeUnistring(&_key);
}
