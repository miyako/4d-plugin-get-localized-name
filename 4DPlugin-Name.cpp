/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Name.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Name
 #	author : miyako
 #	2025/07/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Name.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Name
            
			case 1 :
				Get_localized_name(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
static void _getKey(PA_ObjectRef returnValue, NSURL *url, const char *property, NSURLResourceKey key) {
    
    @autoreleasepool {
        if(url) {
            NSString *localizedName = nil;
            [url getResourceValue:&localizedName forKey:key error:nil];
            if(localizedName) {
                ob_set_s(returnValue, property, [localizedName UTF8String]);
            }
        }
    }
}
#endif

#if VERSIONWIN
DEFINE_GUID(IID_IImageList, 0x46EB5926, 0x582E, 0x4017, 0x9F, 0xDF, 0xE8, 0x99, 0x8D, 0xAA, 0x09, 0x50);
using namespace Gdiplus;
static bool GetEncoderClsid(const WCHAR* format, CLSID* pClsid)
{
    UINT num = 0, size = 0;
    GetImageEncodersSize(&num, &size);
    if (size == 0) return false;

    ImageCodecInfo* pImageCodecInfo = (ImageCodecInfo*)malloc(size);
    if (!pImageCodecInfo) return false;
    GetImageEncoders(num, size, pImageCodecInfo);

    for (UINT i = 0; i < num; i++)
    {
        if (wcscmp(pImageCodecInfo[i].MimeType, format) == 0)
        {
            *pClsid = pImageCodecInfo[i].Clsid;
            free(pImageCodecInfo);
            return true;
        }
    }

    free(pImageCodecInfo);
    return false;
}

static void HICONToBMPBuffer(HICON hIcon, std::vector<uint8_t>& buf) {
    
    ICONINFO iconInfo = {};
    if (!GetIconInfo(hIcon, &iconInfo))
        return;

    BITMAP bmp = {};
    GetObject(iconInfo.hbmColor, sizeof(bmp), &bmp);

    BITMAPINFO bmi = {};
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = bmp.bmWidth;
    bmi.bmiHeader.biHeight      = bmp.bmHeight; // bottom-up
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    HDC hdc = GetDC(NULL);
    std::vector<uint8_t> pixels(bmp.bmWidth * bmp.bmHeight * 4); // 32-bit BGRA

    GetDIBits(hdc, iconInfo.hbmColor, 0, bmp.bmHeight, pixels.data(), &bmi, DIB_RGB_COLORS);
    ReleaseDC(NULL, hdc);

    // Prepare BMP file header
    BITMAPFILEHEADER bfh = {};
    bfh.bfType = 0x4D42; // 'BM'
    bfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    bfh.bfSize = bfh.bfOffBits + static_cast<DWORD>(pixels.size());

    // Write everything to memory buffer
    buf.resize(bfh.bfSize);
    uint8_t* ptr = buf.data();

    // Copy BITMAPFILEHEADER
    memcpy(ptr, &bfh, sizeof(bfh));
    ptr += sizeof(bfh);

    // Copy BITMAPINFOHEADER
    memcpy(ptr, &bmi.bmiHeader, sizeof(bmi.bmiHeader));
    ptr += sizeof(bmi.bmiHeader);

    // Copy pixel data
    memcpy(ptr, pixels.data(), pixels.size());

    // Clean up
    DeleteObject(iconInfo.hbmColor);
    DeleteObject(iconInfo.hbmMask);
}
#endif

void Get_localized_name(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    std::string platformPath;
    PA_ObjectRef item = PA_GetObjectParameter(params, 1);
    if(item){
        
        object_class_t itemClass = _ob_class(item);
        switch (itemClass) {
            case object_class_file:
                file_object_to_path(item, platformPath);
                break;
            case object_class_folder:
                folder_object_to_path(item, platformPath);
                break;
            default:
                break;
        }
        if(platformPath != ""){
            
#if VERSIONWIN
            CUTF16String wstr;
            C_TEXT pp;
            pp.setUTF8String((const uint8_t *)platformPath.c_str(), platformPath.length());
            pp.copyUTF16String(&wstr);
            
#define BUFFERLENGTH 1024
    LPCTSTR lpFile = (LPCTSTR)wstr.c_str();
    DWORD bufferLength = BUFFERLENGTH;
    wchar_t lpResult[BUFFERLENGTH];
            
            HRESULT res =AssocQueryString(
                                          ASSOCF_NONE,
                                          ASSOCSTR_FRIENDLYDOCNAME,
                                          lpFile,
                                          NULL,
                                          lpResult,
                                          &bufferLength
                                          );
            if ((res == S_OK) && ( bufferLength != 0)){
                ob_set_a(returnValue, L"localizedDescription", (const wchar_t *)lpResult);
            }
            
            SHFILEINFO shfi;
            SHGetFileInfo(
                          lpFile,
                          FILE_ATTRIBUTE_NORMAL,
                          &shfi,
                          sizeof(SHFILEINFO),
                          SHGFI_DISPLAYNAME | SHGFI_TYPENAME | (itemClass == object_class_file ? SHGFI_USEFILEATTRIBUTES : 0)
                          );
            
            if (wcslen(shfi.szDisplayName) != 0) {
                ob_set_a(returnValue, L"localizedName", (const wchar_t*)shfi.szDisplayName);
            }
            if (wcslen(shfi.szTypeName) != 0) {
                ob_set_a(returnValue, L"localizedTypeDescription", (const wchar_t*)shfi.szTypeName);
            }
            
            int iconIndex = 0;
            
            if(SHGetFileInfo(
                          lpFile,
                FILE_ATTRIBUTE_NORMAL,
                          &shfi,
                          sizeof(SHFILEINFO),
                SHGFI_SYSICONINDEX | SHGFI_ADDOVERLAYS | SHGFI_LINKOVERLAY
                             )) {
                iconIndex = shfi.iIcon;
                             }
            
            if(iconIndex) {

                IImageList* iml = nullptr;
                if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_IImageList, (void**)&iml)) && iml)
                {
                    HICON hIcon = nullptr;

                    if(SUCCEEDED((IImageListVtbl*)iml->lpVtbl->GetIcon(iml, iconIndex, ILD_TRANSPARENT, &hIcon)) && hIcon)
                    {
                        using namespace Gdiplus;
                        Bitmap* bmp = Bitmap::FromHICON(hIcon);
                        if (bmp)
                        {
                            
                            IStream* pStream = nullptr;
                            if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
                            {
                                CLSID pngClsid;
                                if (GetEncoderClsid(L"image/png", &pngClsid)) {
                                    if (bmp->Save(pStream, &pngClsid, NULL) == Ok)
                                    {
                                        HGLOBAL hMem = NULL;
                                        if (SUCCEEDED(GetHGlobalFromStream(pStream, &hMem)))
                                        {
                                            SIZE_T size = GlobalSize(hMem);
                                            void* pData = GlobalLock(hMem);
                                            std::vector<uint8_t> buf(size);
                                            memcpy(buf.data(), pData, size);
                                            GlobalUnlock(hMem);

                                            PA_Picture p = PA_CreatePicture(buf.data(), buf.size());
                                            ob_set_p(returnValue, L"linkOverlayIcon", p);
                                        }
                                    }
                                }
                            }

                            delete bmp;
                        }

                        DestroyIcon(hIcon);

                        iml->lpVtbl->Release(iml);
                        
                    }

                }

                /*
               
                std::vector<uint8_t>buf(0);
                HICONToBMPBuffer(hIcon, buf);
                
                 */
            }

#endif
            
#if VERSIONMAC
//            ob_set_s(returnValue, "platformPath", platformPath.c_str());
            NSString *str = [NSString stringWithUTF8String:platformPath.c_str()];
            NSURL *url = [NSURL fileURLWithPath:str];
            _getKey(returnValue, url, "localizedName", NSURLLocalizedNameKey);
            _getKey(returnValue, url, "localizedLabel", NSURLLocalizedLabelKey);
            _getKey(returnValue, url, "localizedTypeDescription", NSURLLocalizedTypeDescriptionKey);
//            _getKey(returnValue, url, "localizedFormatDescription", NSURLVolumeLocalizedFormatDescriptionKey);
            NSString *pathExtension = [str pathExtension];
            if(pathExtension) {
                CFStringRef uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension,
                                                                        (__bridge CFStringRef)pathExtension,
                                                                        NULL);
                if (uti) {
                    CFStringRef desc = UTTypeCopyDescription(uti);
                    if (desc) {
                        ob_set_s(returnValue, "localizedDescription", [(__bridge NSString *)desc UTF8String]);
                        CFRelease(desc);
                    }
                    CFRelease(uti);
                }
            }
#endif
        }
    }
    

    PA_ReturnObject(params, returnValue);
}

#pragma mark -

static object_class_t _ob_class(PA_ObjectRef f){
    
    PA_Variable    cbparams[1];
    cbparams[0] = PA_CreateVariable(eVK_Object);
    PA_SetObjectVariable(&cbparams[0], f);
    PA_Variable classObject = PA_ExecuteCommandByID(1730 /*OB Class*/, cbparams, 1);
    if(PA_GetVariableKind(classObject) == eVK_Object){
        PA_ObjectRef i = PA_GetObjectVariable(classObject);
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"name", 4);
        PA_Unistring NAME = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        if(PA_GetObjectPropertyType(i, &NAME) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(i, &NAME);
            PA_Unistring name = PA_GetStringVariable(p);
            
            C_TEXT c;
            c.setUTF16String(&name);
            CUTF8String _name;
            c.copyUTF8String(&_name);
            if(_name == (const uint8_t *)"File") {
                return object_class_file;
            }
            if(_name == (const uint8_t *)"Folder") {
                return object_class_folder;
            }
        }
    }
    
    return object_class_none;
}

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1567 /*4D.Folder*/);
}

static void set_object_property(PA_ObjectRef o, const char *key, PA_Variable value) {
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)key, (uint32_t)strlen(key));
    PA_Unistring _key = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    PA_SetObjectProperty(o, &_key, value);
    PA_DisposeUnistring(&_key);
}
