/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Name.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Name
 #	author : miyako
 #	2025/07/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Name.h"

#pragma mark -

#if VERSIONWIN
CLSID pngClsid;
bool pngClsidValid = false;
DEFINE_GUID(IID_IImageList, 0x46EB5926, 0x582E, 0x4017, 0x9F, 0xDF, 0xE8, 0x99, 0x8D, 0xAA, 0x09, 0x50);
struct BITMAPINFO1BPP
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[2]; // required for 1bpp
};
using namespace Gdiplus;

static bool GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {

    UINT num = 0, size = 0;
    GetImageEncodersSize(&num, &size);
    if (size == 0) return false;

    ImageCodecInfo* pImageCodecInfo = (ImageCodecInfo*)malloc(size);
    if (!pImageCodecInfo) return false;
    GetImageEncoders(num, size, pImageCodecInfo);

    for (UINT i = 0; i < num; i++)
    {
        if (wcscmp(pImageCodecInfo[i].MimeType, format) == 0)
        {
            *pClsid = pImageCodecInfo[i].Clsid;
            free(pImageCodecInfo);
            return true;
        }
    }

    free(pImageCodecInfo);
    return false;
}

static HICON LoadSystemShortcutArrow()
{
    // Get real system directory (handles WOW64/ARM)
    wchar_t sysDir[MAX_PATH] = {};
    UINT len = GetSystemDirectoryW(sysDir, MAX_PATH);
    if (len == 0 || len >= MAX_PATH) return nullptr;

    // Build full path to shell32.dll
    std::wstring shell32Path = sysDir;
    if (shell32Path.back() != L'\\') shell32Path += L'\\';
    shell32Path += L"shell32.dll";

    // Load the arrow icon (resource ID -50)
    HICON hArrow = (HICON)LoadImage(
        NULL,
        shell32Path.c_str(),   // path to DLL
        IMAGE_ICON,
        0, 0,
        LR_SHARED | LR_DEFAULTSIZE
    );

    // Use MAKEINTRESOURCE to specify resource ID (-50)
    if (hArrow == nullptr)
    {
        // fallback: use negative resource ID via MAKEINTRESOURCE
        hArrow = (HICON)LoadImage(
            NULL,
            MAKEINTRESOURCEW(-50),
            IMAGE_ICON,
            0, 0,
            LR_SHARED | LR_DEFAULTSIZE
        );
    }

    return hArrow;
}

bool HICONToBGRAWithShortcutArrow(HICON hIcon, std::vector<uint8_t>& outPixels, int& width, int& height)
{
    if (!hIcon) return false;

    ICONINFO ii = {};
    if (!GetIconInfo(hIcon, &ii)) return false;

    BITMAP bmpColor = {};
    GetObject(ii.hbmColor, sizeof(bmpColor), &bmpColor);
    width = bmpColor.bmWidth;
    height = bmpColor.bmHeight;
    outPixels.resize(width * height * 4, 0);

    BITMAPINFO bi = {};
    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth = width;
    bi.bmiHeader.biHeight = -height; // top-down
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    void* pBits = nullptr;
    HDC hdcScreen = GetDC(NULL);
    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    HBITMAP hbm = CreateDIBSection(hdcMem, &bi, DIB_RGB_COLORS, &pBits, NULL, 0);
    if (!hbm) { DeleteDC(hdcMem); ReleaseDC(NULL, hdcScreen); return false; }

    HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);

    // Draw the base icon
    DrawIconEx(hdcMem, 0, 0, hIcon, width, height, 0, NULL, DI_NORMAL);

    // Draw the arrow
    //HICON hArrow = (HICON)LoadImage(NULL, L"C:\\Windows\\System32\\shell32.dll,-50",
   //     IMAGE_ICON, 0, 0, LR_SHARED);
    HICON hArrow = LoadSystemShortcutArrow();
    if (hArrow)
    {
        int arrowSize = width / 4;
        int arrowX = 0;
        int arrowY = height - arrowSize;
        DrawIconEx(hdcMem, arrowX, arrowY, hArrow, arrowSize, arrowSize, 0, NULL, DI_NORMAL);
    }

    // Copy pixels from DIB section to outPixels
    if (pBits)
        memcpy(outPixels.data(), pBits, width * height * 4);

    // Cleanup
    SelectObject(hdcMem, hbmOld);
    DeleteObject(hbm);
    DeleteDC(hdcMem);
    ReleaseDC(NULL, hdcScreen);

    DeleteObject(ii.hbmColor);
    DeleteObject(ii.hbmMask);

    return true;
}
#endif

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Name
            
            case kInitPlugin:
            case kServerInitPlugin:
#if VERSIONWIN
                pngClsidValid = GetEncoderClsid(L"image/png", &pngClsid);
#endif
                break;
                
			case 1 :
				Get_localized_name(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
static void _getKey(PA_ObjectRef returnValue, NSURL *url, const char *property, NSURLResourceKey key) {
    
    @autoreleasepool {
        if(url) {
            NSString *localizedName = nil;
            [url getResourceValue:&localizedName forKey:key error:nil];
            if(localizedName) {
                ob_set_s(returnValue, property, [localizedName UTF8String]);
            }
        }
    }
}
#endif

void Get_localized_name(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    std::string platformPath;
    PA_ObjectRef item = PA_GetObjectParameter(params, 1);
    if(item){
        
        object_class_t itemClass = _ob_class(item);
        switch (itemClass) {
            case object_class_file:
                file_object_to_path(item, platformPath);
                break;
            case object_class_folder:
                folder_object_to_path(item, platformPath);
                break;
            default:
                break;
        }
        if(platformPath != ""){
            
#if VERSIONWIN
            CUTF16String wstr;
            C_TEXT pp;
            pp.setUTF8String((const uint8_t *)platformPath.c_str(), platformPath.length());
            pp.copyUTF16String(&wstr);
            
#define BUFFERLENGTH 1024
    LPCTSTR lpFile = (LPCTSTR)wstr.c_str();
    DWORD bufferLength = BUFFERLENGTH;
    wchar_t lpResult[BUFFERLENGTH];
            
            HRESULT res =AssocQueryString(
                                          ASSOCF_NONE,
                                          ASSOCSTR_FRIENDLYDOCNAME,
                                          lpFile,
                                          NULL,
                                          lpResult,
                                          &bufferLength
                                          );
            if ((res == S_OK) && ( bufferLength != 0)){
                ob_set_a(returnValue, L"localizedDescription", (const wchar_t *)lpResult);
            }
            
            SHFILEINFO shfi;
            SHGetFileInfo(
                          lpFile,
                          FILE_ATTRIBUTE_NORMAL,
                          &shfi,
                          sizeof(SHFILEINFO),
                          SHGFI_DISPLAYNAME | SHGFI_TYPENAME | (itemClass == object_class_file ? SHGFI_USEFILEATTRIBUTES : 0)
                          );
            
            if (wcslen(shfi.szDisplayName) != 0) {
                ob_set_a(returnValue, L"localizedName", (const wchar_t*)shfi.szDisplayName);
            }
            if (wcslen(shfi.szTypeName) != 0) {
                ob_set_a(returnValue, L"localizedTypeDescription", (const wchar_t*)shfi.szTypeName);
            }
            
            int iconIndex = 0;
            
            if(SHGetFileInfo(
                             lpFile,
                             FILE_ATTRIBUTE_NORMAL | (itemClass == object_class_folder ? FILE_ATTRIBUTE_DIRECTORY : 0),
                             &shfi,
                             sizeof(SHFILEINFO),
                             SHGFI_SYSICONINDEX | SHGFI_ADDOVERLAYS | SHGFI_LINKOVERLAY
                             )) {
                                 iconIndex = shfi.iIcon;
                             }
            
            if(iconIndex) {

                IImageList* iml = nullptr;
                if (SUCCEEDED(SHGetImageList(SHIL_JUMBO, IID_IImageList, (void**)&iml)) && iml)
                {
                    if (SUCCEEDED(iml->lpVtbl->SetOverlayImage(iml, 1, 1)))
                    {
                        HICON hIcon = nullptr;
                        if (SUCCEEDED(iml->lpVtbl->GetIcon(iml, iconIndex, ILD_TRANSPARENT | ILD_PRESERVEALPHA, &hIcon)) && hIcon)
                        {
                            std::vector<uint8_t> buf;
                               int width = 0, height = 0;
                               if (HICONToBGRAWithShortcutArrow(hIcon, buf, width, height))
                               {
                                   PA_Picture p = PA_CreatePicture(buf.data(), buf.size());
                                   ob_set_p(returnValue, L"linkOverlayIcon", p);
                               }
                            
                            /*
                                Bitmap* bmp = Bitmap::FromHICON(hIcon);

                                if (bmp) {
                                    if (pngClsidValid) {

                                        IStream* pStream = nullptr;
                                        if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
                                        {
                                            if (bmp->Save(pStream, &pngClsid, NULL) == Ok)
                                            {
                                                HGLOBAL hMem = NULL;
                                                if (SUCCEEDED(GetHGlobalFromStream(pStream, &hMem)))
                                                {
                                                    SIZE_T size = GlobalSize(hMem);
                                                    void* pData = GlobalLock(hMem);
                                                    std::vector<uint8_t> buf(size);
                                                    memcpy(buf.data(), pData, size);

                                                    PA_Picture p = PA_CreatePicture(buf.data(), buf.size());
                                                    ob_set_p(returnValue, L"linkOverlayIcon", p);

                                                    GlobalUnlock(hMem);
                                                }
                                            }
                                            pStream->Release();
                                        }

                                    }

                                    delete bmp;
                                }
                            */
                            
                            DestroyIcon(hIcon);
                        }
                    }

                   
                    iml->lpVtbl->Release(iml);
                }
            }
#endif
            
#if VERSIONMAC
//            ob_set_s(returnValue, "platformPath", platformPath.c_str());
            NSString *str = [NSString stringWithUTF8String:platformPath.c_str()];
            NSURL *url = [NSURL fileURLWithPath:str];
            _getKey(returnValue, url, "localizedName", NSURLLocalizedNameKey);
            _getKey(returnValue, url, "localizedLabel", NSURLLocalizedLabelKey);
            _getKey(returnValue, url, "localizedTypeDescription", NSURLLocalizedTypeDescriptionKey);
//            _getKey(returnValue, url, "localizedFormatDescription", NSURLVolumeLocalizedFormatDescriptionKey);
            NSString *pathExtension = [str pathExtension];
            if(pathExtension) {
                CFStringRef uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension,
                                                                        (__bridge CFStringRef)pathExtension,
                                                                        NULL);
                if (uti) {
                    CFStringRef desc = UTTypeCopyDescription(uti);
                    if (desc) {
                        ob_set_s(returnValue, "localizedDescription", [(__bridge NSString *)desc UTF8String]);
                        CFRelease(desc);
                    }
                    CFRelease(uti);
                }
            }
#endif
        }
    }
    

    PA_ReturnObject(params, returnValue);
}

#pragma mark -

static object_class_t _ob_class(PA_ObjectRef f){
    
    PA_Variable    cbparams[1];
    cbparams[0] = PA_CreateVariable(eVK_Object);
    PA_SetObjectVariable(&cbparams[0], f);
    PA_Variable classObject = PA_ExecuteCommandByID(1730 /*OB Class*/, cbparams, 1);
    if(PA_GetVariableKind(classObject) == eVK_Object){
        PA_ObjectRef i = PA_GetObjectVariable(classObject);
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"name", 4);
        PA_Unistring NAME = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        if(PA_GetObjectPropertyType(i, &NAME) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(i, &NAME);
            PA_Unistring name = PA_GetStringVariable(p);
            
            C_TEXT c;
            c.setUTF16String(&name);
            CUTF8String _name;
            c.copyUTF8String(&_name);
            if(_name == (const uint8_t *)"File") {
                return object_class_file;
            }
            if(_name == (const uint8_t *)"Folder") {
                return object_class_folder;
            }
        }
    }
    
    return object_class_none;
}

static bool _object_to_path(PA_ObjectRef f, std::string& path, int type) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(type, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = std::string((const char *)u8.c_str(), u8.size());
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static bool file_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1566 /*4D.File*/);
}

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
    
    return _object_to_path(f, path, 1567 /*4D.Folder*/);
}

static void set_object_property(PA_ObjectRef o, const char *key, PA_Variable value) {
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)key, (uint32_t)strlen(key));
    PA_Unistring _key = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    PA_SetObjectProperty(o, &_key, value);
    PA_DisposeUnistring(&_key);
}
